#pragma once

/*
* SDK generated by Dumper-DNA
*/

// Package: BP_MathFunctionLibrary

#include "Basic.hpp"

#include "BP_MathFunctionLibrary_classes.hpp"
#include "BP_MathFunctionLibrary_parameters.hpp"


namespace SDK
{

// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.ArrayMaxSameElement
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FString>&                  TargetArray                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  MaxSameElement                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathFunctionLibrary_C::ArrayMaxSameElement(TArray<class FString>& TargetArray, class UObject* __WorldContext, int32* MaxSameElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "ArrayMaxSameElement");

	Params::BP_MathFunctionLibrary_C_ArrayMaxSameElement Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	TargetArray = std::move(Parms.TargetArray);

	if (MaxSameElement != nullptr)
		*MaxSameElement = Parms.MaxSameElement;
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.ArrayFilter
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>&                          TargetArray                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<int32>&                          BaseArray                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>*                          Return                                                 (Parm, OutParm)

void UBP_MathFunctionLibrary_C::ArrayFilter(TArray<int32>& TargetArray, TArray<int32>& BaseArray, class UObject* __WorldContext, TArray<int32>* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "ArrayFilter");

	Params::BP_MathFunctionLibrary_C_ArrayFilter Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.BaseArray = std::move(BaseArray);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	TargetArray = std::move(Parms.TargetArray);
	BaseArray = std::move(Parms.BaseArray);

	if (Return != nullptr)
		*Return = std::move(Parms.Return);
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.Schimidt正交化
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Alpha1                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Alpha2                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   alpha3                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Beta1                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Beta2                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Beta3                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathFunctionLibrary_C::Schimidt正交化(const struct FVector& Alpha1, const struct FVector& Alpha2, const struct FVector& alpha3, class UObject* __WorldContext, struct FVector* Beta1, struct FVector* Beta2, struct FVector* Beta3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "Schimidt正交化");

	Params::BP_MathFunctionLibrary_C_Schimidt正交化 Parms{};

	Parms.Alpha1 = std::move(Alpha1);
	Parms.Alpha2 = std::move(Alpha2);
	Parms.alpha3 = std::move(alpha3);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Beta1 != nullptr)
		*Beta1 = std::move(Parms.Beta1);

	if (Beta2 != nullptr)
		*Beta2 = std::move(Parms.Beta2);

	if (Beta3 != nullptr)
		*Beta3 = std::move(Parms.Beta3);
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.生成一组包含给定向量的Basis
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   N                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Alpha1                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Alpha2                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         alpha3                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathFunctionLibrary_C::生成一组包含给定向量的Basis(const struct FVector& N, class UObject* __WorldContext, struct FVector* Alpha1, struct FVector* Alpha2, struct FVector* alpha3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "生成一组包含给定向量的Basis");

	Params::BP_MathFunctionLibrary_C_生成一组包含给定向量的Basis Parms{};

	Parms.N = std::move(N);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Alpha1 != nullptr)
		*Alpha1 = std::move(Parms.Alpha1);

	if (Alpha2 != nullptr)
		*Alpha2 = std::move(Parms.Alpha2);

	if (alpha3 != nullptr)
		*alpha3 = std::move(Parms.alpha3);
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.BezierCurve
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FVector>&                 P                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   N                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   T                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         B_T_                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathFunctionLibrary_C::BezierCurve(TArray<struct FVector>& P, int32 N, float T, class UObject* __WorldContext, struct FVector* B_T_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "BezierCurve");

	Params::BP_MathFunctionLibrary_C_BezierCurve Parms{};

	Parms.P = std::move(P);
	Parms.N = N;
	Parms.T = T;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	P = std::move(Parms.P);

	if (B_T_ != nullptr)
		*B_T_ = std::move(Parms.B_T_);
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.Combination
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   N                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   K                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathFunctionLibrary_C::Combination(int32 N, int32 K, class UObject* __WorldContext, float* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "Combination");

	Params::BP_MathFunctionLibrary_C_Combination Parms{};

	Parms.N = N;
	Parms.K = K;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.Factorial
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   N                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  N_                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathFunctionLibrary_C::Factorial(int32 N, class UObject* __WorldContext, int32* N_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "Factorial");

	Params::BP_MathFunctionLibrary_C_Factorial Parms{};

	Parms.N = N;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (N_ != nullptr)
		*N_ = Parms.N_;
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.RodriguesRotationFormula
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   K                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   V                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   theta                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         v_rot                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathFunctionLibrary_C::RodriguesRotationFormula(const struct FVector& K, const struct FVector& V, float theta, class UObject* __WorldContext, struct FVector* v_rot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "RodriguesRotationFormula");

	Params::BP_MathFunctionLibrary_C_RodriguesRotationFormula Parms{};

	Parms.K = std::move(K);
	Parms.V = std::move(V);
	Parms.theta = theta;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (v_rot != nullptr)
		*v_rot = std::move(Parms.v_rot);
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.EnmityCurve
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   HpPercent                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BuffRate                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  Modifier                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathFunctionLibrary_C::EnmityCurve(float HpPercent, float BuffRate, class UObject* __WorldContext, float* Modifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "EnmityCurve");

	Params::BP_MathFunctionLibrary_C_EnmityCurve Parms{};

	Parms.HpPercent = HpPercent;
	Parms.BuffRate = BuffRate;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Modifier != nullptr)
		*Modifier = Parms.Modifier;
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.概率执行
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Probability                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   isSuccess                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_MathFunctionLibrary_C::概率执行(float Probability, class UObject* __WorldContext, bool* isSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "概率执行");

	Params::BP_MathFunctionLibrary_C_概率执行 Parms{};

	Parms.Probability = Probability;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (isSuccess != nullptr)
		*isSuccess = Parms.isSuccess;
}


// Function BP_MathFunctionLibrary.BP_MathFunctionLibrary_C.向量夹角
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   向量1                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   向量2                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  夹角                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathFunctionLibrary_C::向量夹角(const struct FVector& 向量1, const struct FVector& 向量2, class UObject* __WorldContext, float* 夹角)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathFunctionLibrary_C", "向量夹角");

	Params::BP_MathFunctionLibrary_C_向量夹角 Parms{};

	Parms.向量1 = std::move(向量1);
	Parms.向量2 = std::move(向量2);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (夹角 != nullptr)
		*夹角 = Parms.夹角;
}

}

